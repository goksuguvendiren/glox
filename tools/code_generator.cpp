//
// Created by Göksu Güvendiren on 8/19/21.
//

#include <iostream>
#include <sstream>
#include <vector>
#include <fstream>

#include "code_generator.hpp"

namespace {
std::string generate_header()
{
    std::stringstream stream;

    stream << "//\n";
    stream << "// Auto-generated by Goksu Guvendiren Bakir. \n";
    stream << "//\n\n";

    stream << "#pragma once\n\n";

    stream << "#include <utility>\n";
    stream << "#include \"../token.hpp\"\n";
    stream << "#include \"expression.hpp\"\n";

    return stream.str();
}

std::string generate_class_definition(const std::string& class_name)
{
    std::stringstream stream;

    stream << "namespace glox::repr\n";
    stream << "{\n";
    stream << "\tclass " + class_name + " : public repr::expression\n";
    stream << "\t{\n";

    return stream.str();
}

std::string generate_end_of_class()
{
    std::stringstream stream;

    stream << "\t};\n";
    stream << "}";

    return stream.str();
}

bool gets_template(const std::string& param)
{
    return false;
}

bool trivially_copyable(const std::string& param)
{
    if (param == "double") return true;

    return false;
}

std::string generate_public_functions(const glox::code_generator::type_definition& type)
{
    std::stringstream stream;

    stream << "\tpublic:\n";
    stream << "\t\t" << type.type_name << "(\n";

    for (int i = 0; i < type.parameters.size(); ++i)
    {
        auto param = type.parameters[i];
        stream << "\t\t";
        if (trivially_copyable(param)) stream << param;
        else
        {
            stream << "std::unique_ptr<" << param;
            if (gets_template(param)) stream << "<T>";
            stream << ">";
        }
        stream << " expr" << std::to_string(i) << ",\n";
    }
    // remove the last comma
    stream.seekp(-2, std::ios_base::end);
    stream << "\n";


    stream << "\t\t) : \n";
    for (int i = 0; i < type.parameters.size(); ++i)
    {
        auto param = type.parameters[i];
        auto varname = "expr" + std::to_string(i);
        stream << "\t\t\t" << varname << "(std::move(" << varname << ")),\n";
    }
    // remove the last comma
    stream.seekp(-2, std::ios_base::end);
    stream << "\n";

    stream << "\t\t{}\n";

    stream << "\n";
    stream << "~" + type.type_name + "() = default;\n\n";

    return stream.str();
}

std::string generate_private_members(const glox::code_generator::type_definition& type)
{
    std::stringstream stream;

    stream << "\tprivate:\n";

    for (int i = 0; i < type.parameters.size(); ++i)
    {
        auto param = type.parameters[i];
        auto varname = "expr" + std::to_string(i);
        stream << "\t\t";

        if (trivially_copyable(param)) stream << param;
        else
        {
            stream << "std::unique_ptr<" << param;
            if (gets_template(param)) stream << "<T>";
            stream << ">";
        }

        stream << " " << varname << ";\n";
    }

    return stream.str();
}

std::string generate_visitor_function(const std::string& class_name)
{
    std::stringstream stream;

    stream << "\t\tstd::any accept(const visitor& visitor) const\n";
    stream << "\t\t{\n";
    stream << "\t\t\treturn visitor.visit_" << class_name << "_expr(*this);\n";
    stream << "\t\t}\n";

    return stream.str();
}
}

void glox::code_generator::generate_ast(const std::string &output_folder,
                                        std::vector<glox::code_generator::type_definition> &expressions)
{
    for (auto& expression : expressions)
    {
//        std::stringstream stream;
        std::ofstream stream(output_folder + "/" + expression.type_name + ".hpp");

        stream << generate_header();
        stream << "\n";
        stream << generate_class_definition(expression.type_name);
        stream << generate_public_functions(expression);
        stream << generate_private_members(expression);
        stream << "\n";
        stream << generate_visitor_function(expression.type_name);
        stream << generate_end_of_class();

        if (!stream.is_open()) {
            std::cout << "failed to open " << expression.type_name << '\n';
        }
    }
}
