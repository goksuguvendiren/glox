//
// Created by Göksu Güvendiren on 8/19/21.
//

#include <iostream>
#include <sstream>
#include <vector>

#include "code_generator.hpp"

std::string generate_header()
{
    std::stringstream stream;

    stream << "//\n";
    stream << "// Auto-generated by Goksu Guvendiren Bakir. \n";
    stream << "//\n\n";

    stream << "#pragma once\n\n";

    stream << "#include <utility>\n";
    stream << "#include \"../token.hpp\"\n";
    stream << "#include \"expression.hpp\"\n";

    return stream.str();
}

std::string generate_class_definition(const std::string& class_name)
{
    std::stringstream stream;

    stream << "namespace glox::repr\n";
    stream << "{\n";
    stream << "\ttemplate <class T>\n";
    stream << "\tclass " + class_name + " : glox::repr::expression<T>\n";
    stream << "\t{\n";

    return stream.str();
}

std::string generate_end_of_class()
{
    std::stringstream stream;

    stream << "\t};\n";
    stream << "}";

    return stream.str();
}

std::string generate_public_functions(const glox::code_generator::type_definition& type)
{
    std::stringstream stream;

    stream << "\tpublic:\n";
    stream << "\t\t" << type.type_name << "(\n";

    for (int i = 0; i < type.parameters.size(); ++i)
    {
        auto param = type.parameters[i];
        stream << "\t\t\t" << param << " expr" << std::to_string(i) << "\n";
    }

    stream << "\t\t) : \n";
    for (int i = 0; i < type.parameters.size(); ++i)
    {
        auto param = type.parameters[i];
        auto varname = "expr" + std::to_string(i);
        stream << "\t\t\t" << varname << "(std::move(" << varname << ")),\n";
    }
    // remove the last comma
    stream.seekp(-2, std::ios_base::end);
    stream << "\n";

    stream << "\t\t{}\n";

    return stream.str();
}

std::string generate_private_members(const glox::code_generator::type_definition& type)
{
    std::stringstream stream;

    stream << "\tprivate:\n";

    for (int i = 0; i < type.parameters.size(); ++i)
    {
        auto param = type.parameters[i];
        auto varname = "expr" + std::to_string(i);
        stream << "\t\t\t" << param << " " << varname << ";\n";
    }

    return stream.str();
}

std::string generate_visitor_function(const std::string& class_name)
{
    std::stringstream stream;

    stream << "\t\t\tT accept(visitor<T> visitor)\n";
    stream << "\t\t\t{\n";
    stream << "\t\t\t\treturn visitor.visit_" << class_name << "_expr();\n";
    stream << "\t\t\t}\n";

    return stream.str();
}

void glox::code_generator::generate_ast(const std::string &output_folder, const std::string &filename,
                                        std::vector<glox::code_generator::type_definition> &expressions)
{
    for (auto& expression : expressions)
    {
        std::stringstream stream;

        stream << generate_header();
        stream << "\n";
        stream << generate_class_definition(expression.type_name);
        stream << generate_public_functions(expression);
        stream << generate_private_members(expression);
        stream << "\n";
        stream << generate_visitor_function(expression.type_name);
        stream << generate_end_of_class();

        std::cout << stream.str() << '\n';
    }
}
